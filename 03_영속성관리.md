# 3장 영속성 관리
## 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전해서 공유 가능
- 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 공유하면 안된다
- 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점(트랜잭션의 시작)에 커넥션을 획득한다.


## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경

## 엔티티의 생명 주기
- 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태

## 영속성 컨텍스트의 특징
- 영속성 컨텍스트와 식별자 값: 영속 상태는 식별자 값이 반드시 있어야 한다.
- 영속성 컨텍스트와 데이터베이스 저장: 트랜잭션을 커밋하는 순간 데이터베이스에 반영(flush)
- 영속성 컨텍스트가 엔티티를 관리함의 장점
1) 1차 캐시
2) 동일성 보장
3) 트랜잭션을 지원하는 쓰기 지연
4) 변경 감지
5) 지연 로딩

### 엔티티 조회
1) 내부의 Map이 있는데 @Id를 키, Entity를 값으로 하여 저장
2) em.find()를 호출하면 1차 캐시에서 찾고, 없으면 데이터베이스를 조회
Q) 프로그램 시작할 때, 자주 호출될 엔티티를 findAll()해놓으면 1차 캐시에 웜업되면서 성능이 향상될까?
3) 영속 엔티티의 동일성 보장
4) JPA는 Repeatable Read 등급의 트랜잭션 격리 수준을 제공(Read Uncommitted -> Read Committed -> Repeatable Read -> Serializable)

### 엔티티 등록
- 트랜잭션을 커밋하기 전까지 내부 쿼리 저장소에 모아놓고 한번에 flush한다(쓰기 지연)

### 엔티티 수정
1) 엔티티 매니저 내부에서 flush가 호출
2) 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다
3) 변경된 엔티티가 있으면 수정쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다
4) 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다
5) 데이터베이스 트랜잭션을 커밋한다.
- JPA 기본 전략은 엔티티의 모든 필드를 업데이트한다.
(몽고디비쓸 때 한번 Dynamic Update를 써봐야겠다)

### 플러시
플러시하는 방법
- em.flush를 직접 호출
- 트랜잭션 커밋 시 자동 호출
- JPQL 쿼리 실행시 자동 호출

### 준영속
1. em.detach(entity)
2. em.clear(): 영속성 컨텍스트를 완전히 초기화
3. em.close(): 영속성 컨텍스트를 종료
- 1차캐시, 쓰기 지연, 더티 체킹, 지연 로딩 등 모든 기능 제공X
- 준영속상태는 한번 영속상태였으므로 식별자 값은 가지고 있음
- Lazy Loading은 프록시 객체를 실제 사용할 때 가지고 오는건데, 불가
