# 4장 엔티티 매핑
## @Entity
이 어노테이션이 붙은 클래스는 JPA가 관리해줌
- name: JPA에서 사용할 엔티티 이름
- 주의사항: 기본 생성자는 필수
- final 클래스, enum, interface, inner클래스에서는 사용 불가
- 저장할 필드에 final을 사용하면 안된다.

## @Table
엔티티와 매핑할 테이블을 지정, 생략하면 엔티티 이름을 테이블 이름으로 사용
- name: 매핑할 테이블 이름
- catalog: catalog 기능이 있는 데이터베이스에서 catalog를 매핑
- schema: schema 기능이 있는 데이터베이스에서 schema를 매핑
- uniqueConstraints: DDL 생성 시에 유니크 제약 조건을 만든다. 스키마 자동 생성 기능을 사용해서 DDL을 만들 때만 사용
종민's 알아봄: https://www.baeldung.com/jpa-unique-constraints
@Column(unique=true)는 하나의 필드에만 적용이 가능하다
```
@Table(
	name="entities",
	uniqueConstraints={
		@UniqueConstraint(
			columnNames={"column1","column2"}
		)
	}
)
```
와 같이 사용 가능

## 다양한 매핑
- 자바의 enum을 사용하려면 @Enumerated로 매핑해야 함
- 자바의 날짜 타입은 @Temporal을 사용해서 매핑

Q) 그냥 LocalDateTIme 형식으로 쓰면 안되나?
- 설명 필드와 같이 긴 글들은 varchar대신 CLOB로 지정해야 함(@Lob)

## ddl auto 속성
- create: 기존 테이블을 삭제하고 새로 생성 drop + create
- create-drop: create 속성에 추가로 애플리케이션을 종료할 때 생성한 ddl을 제거한다
- update: 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정
- validate: 테이블과 매핑정보를 비교해서 차이가 있으면 경고하고 어플리케이션을 실행하지 않음
운영서버에서는 이런거 쓰면 안된다!

이름 매핑 전략 변경하기
- hibernate.ejb.naming_strategy를 이용하면 자바의 카멜 케이스를 테이블의 언더스코어 표기법으로 매핑해준다. 
- spring data jpa에서는 그냥 기본으로 이게 되어 있는듯 하다

## 기본 키 매핑
- 직접 할당: 기본 키를 애플리케이션에서 직접 할당한다.
- 자동 생성: 대리 키 사용 방식
1) IDENTITY
- 기본 키 생성을 데이터베이스에 위임
- MySQL, PostgreSQl, 등에서 사용한다.
- 주의: 엔티티를 데이터베이스에 저장 해야 식별자를 구할 수 있으므로 persist를 호출하는 즉시 insert 쿼리가 나가게 되어 쓰기 지연이 동작하지 않는다.
2) SEQUENCE
- 데이터베이스 시퀀스를 사용해서 기본 키를 할당
- CREATE SEQUENCE BOARD_SEQ START WITH 1 INCREMENT BY 1;
- @SequenceGenerator
3) TABLE
- 키 생성 테이블을 활용
-시퀀스 전략과 내부 동작 방식은 같다.
4) Auto
- @GeneratedValue만 해줘도 디폴트는 auto임
- 만약에 mysql이 아니라 오라클을 선택하면 sequence를 미리 만들어 놔야한다.

## 정리
- 데이터베이스 기본 키는 null이 아니어야하고 유일해야 하며 변해선 안된다.
- 테이블의 기본 키는 자연키(비즈니스에 의미있는), 대리키(의미없는) 키 선정 방식이 있음
- 비즈니스 환경은 언젠가 변하므로 대리키 사용을 권장

## @Column
- name: 컬럼 이름
- insertable: false로 하면 이 필드는 저장하지 않음
종민's 알아봄: 
```
@Transient means: this attribute is not persistent at all. It's not handled by JPA. Every time you get an entity from the database, the attribute will be null (or whatever it's initialized to by the no-arg constructor).

insertable=false means that JPA won't include the column in the insert statement when saving the entity. But it will when updating the entity, and it will load it from the database.
```
https://stackoverflow.com/questions/19088223/difference-between-insertable-false-and-transient-in-hibernate

- updatable: false옵션은 읽기 전용일 때!
- table: 하나의 엔티티를 두개 이상의 테이블에 매핑할 때
- nullable: false로 하면 ddl 생성 시에 not null 붙음
- unique: 한 컬럼에 조건을 걸 때만! 여러개일땐 uniqueConstraints
- columnDefinition: 데이터베이스 칼럼 정보를 직접 줄 수 있다
- length: 문자 길이 제약
- precision, scale: 아주 큰 숫자나 정밀한 소수를 다룰 때 사용
## @Enumerated
- EnumType.ORDINAL : enum의 정의된 순서를 디비에 저장. 
- EnumType.STRING : 이름 그대로 string으로 저장.

본인은 enum을 쓰는 이유 자체가 비즈니스적으로 의미있게 구분하기 위함이라고 생각해서 STRING을 선호함. 그래야 순서가 바뀌거나 실수로 중간에 다른걸 끼워넣어도 안깨짐

ex) enum class OAuthProvider{Google, Naver} 있는데 중간에 알파벳 순서로 한다고 Kakao를 끼워넣으면 이미 디비에는 Naver 2로 되어 있을 텐데 Kakao가 2로 들어오고 Naver가 3으로 바뀌면 멘붕!

그거도 그렇고 데이터베이스 쓱쓱 볼때 어렵다.
## @Temporal
- TemporalType.DATE:날짜, 데이터베이스 date 타입과 매핑
- TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑
- TemporalType.TIMESTAMP: 날짜, 시간, 데이터베이스 timestamp 타입과 매핑
## @Lob
- CLOB: string, char[]
- BLOB: binary, byte[]
## @Transient
- 데이터베이스에 저장하지도 않고 조회하지도 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.
## @Access
- AccessType.FIELD: 필드에 직접 접근한다.
- AccessType.PROPERTY: getter를 사용한다.
가끔 getter가 단순히 return this.field 역할이 아니고 간단한 로직처리를 통해 결과를 반환하는 경우가 있는데 이럴때 쓰면 좋겠다!

